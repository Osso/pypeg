"""
pyPEG parsing framework

pyPEG offers a packrat parser as well as a framework to parse and output
languages for Python 2.7 and 3.x, see http://fdik.org/pyPEG2

Copyleft 2012, Volker Birk.
This program is under GNU General Public License 2.0.
"""


from __future__ import unicode_literals
try:
    range = xrange
    str = unicode
except NameError:
    pass


__version__ = 2.5
__author__ = "Volker Birk"
__license__ = "This program is under GNU General Public License 2.0."
__url__ = "http://fdik.org/pyPEG"


import re
import sys
import weakref
import warnings
from functools import reduce
from types import FunctionType
from collections import namedtuple
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict


word = re.compile(r"\w+")
"""Regular expression for scanning a word."""

_RegEx = type(word)

restline = re.compile(r".*")
"""Regular expression for rest of line."""

whitespace = re.compile("(?m)\s+")
"""Regular expression for scanning whitespace."""

comment_sh  = re.compile(r"\#.*")
"""Shell script style comment."""

comment_cpp = re.compile(r"//.*")
"""C++ style comment."""

comment_c   = re.compile(r"(?m)/\*.*?\*/")
"""C style comment without nesting comments."""

comment_pas = re.compile(r"(?m)\(\*.*?\*\)")
"""Pascal style comment without nesting comments."""


def _card(n, thing):
    # Reduce unnecessary recursions
    if len(thing) == 1:
        return n, thing[0]
    else:
        return n, thing


def some(*thing):
    """At least one occurrence of thing, + operator.
    Inserts -2 as cardinality before thing.
    """
    return _card(-2, thing)


def maybe_some(*thing):
    """No thing or some of them, * operator.
    Inserts -1 as cardinality before thing.
    """
    return _card(-1, thing)


def optional(*thing):
    """Thing or no thing, ? operator.
    Inserts 0 as cardinality before thing.
    """
    return _card(0, thing)


def csl(*thing):
    """Generate a grammar for a simple comma separated list."""
    # reduce unnecessary recursions
    if len(thing) == 1:
        L = [thing[0]]
        L.extend(maybe_some(",", blank, thing[0]))
        return tuple(L)
    else:
        L = list(thing)
        L.append(-1)
        L2 = [",", blank]
        L2.extend(tuple(thing))
        L.append(tuple(L2))
        return tuple(L)


def attr(name, thing=word, subtype=None):
    """Generate an Attribute with that name, referencing the thing.

    Instance variables:
        Class       reference to Attribute class generated by namedtuple()
    """
    if __debug__:
        if isinstance(thing, tuple):
            warnings.warn(type(thing).__name__ + " not recommended as grammar of attribute "
                    + repr(name), SyntaxWarning)
    return attr.Class(name, thing, subtype)

attr.Class = namedtuple("Attribute", ("name", "thing", "subtype"))


def flag(name, thing):
    """Generate an Attribute with that name which is valued True or False."""
    return attr(name, thing, "Flag")


def attributes(grammar, invisible=False):
    """Iterates all attributes of a grammar."""
    if type(grammar) == attr.Class and (invisible or grammar.name[0] != "_"):
        yield grammar
    elif type(grammar) == tuple:
        for e in grammar:
            for a in attributes(e, invisible):
                yield a


class RegEx(object):
    """Regular Expression.

    Instance Variables:
        regex       pre-compiled object from re.compile()
    """

    def __init__(self, value):
        self.regex = re.compile(value, re.U)
        self.search = self.regex.search
        self.match = self.regex.match
        self.split = self.regex.split
        self.findall = self.regex.findall
        self.finditer = self.regex.finditer
        self.sub = self.regex.sub
        self.subn = self.regex.subn
        self.flags = self.regex.flags
        self.groups = self.regex.groups
        self.groupindex = self.regex.groupindex
        self.pattern = value

    def __str__(self):
        return self.pattern

    def __repr__(self):
        return type(self).__name__ + "(" + repr(self.pattern) + ")"


class Literal(object):
    """Literal value."""
    _basic_types = (bool, int, float, complex, str, bytes, bytearray, list,
            tuple, range, set, frozenset, dict)
    def __init__(self, value):
        if isinstance(self, Literal._basic_types):
            pass
        else:
            self.value = value

    def __str__(self):
        if isinstance(self, Literal._basic_types):
            return super(Literal, self).__str__()
        else:
            return str(self.value)

    def __repr__(self):
        if isinstance(self, Literal._basic_types):
            return type(self).__name__ + "(" + super(Literal, self).__repr__() + ")"
        else:
            return type(self).__name__ + "(" + repr(self.value) + ")"

    
class List(list):
    """A List of things."""

    def __init__(self, *args, **kwargs):
        """Construct a List, and construct its attributes from keyword
        arguments.
        """
        if len(args) == 1:
            if isinstance(args[0], str):
                self.append(args[0])
            else:
                super(List, self).__init__(args[0])
        else:
            super(List, self).__init__(args)

        for k, v in kwargs:
            setattr(self, k, v)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return ''.join((type(self).__name__, "(", super(List, self).__repr__(), ")"))


class _UserDict(object):
    # UserDict cannot be used because of metaclass conflicts
    def __init__(self, *args, **kwargs):
        self.data = dict(*args, **kwargs)
    def __len__(self):
        return len(self.data)
    def __getitem__(self, key):
        return self.data[key]
    def __setitem__(self, key, value):
        self.data[key] = value
    def __delitem__(self, key):
        del self.data[key]
    def __iter__(self):
        return self.data.keys()
    def __contains__(self, item):
        return item in self.data
    def items(self):
        return self.data.items()
    def keys(self):
        return self.data.keys()
    def values(self):
        return self.data.values()
    def clear(self):
        self.data.clear()
    def copy(self):
        return self.data.copy()


class Namespace(_UserDict):
    """A dictionary of things, indexed by their name."""

    def __init__(self, **kwargs):
        """Initialize an OrderedDict containing the data of the Namespace.
        Arguments are being put into the Namespace, keyword arguments give the
        attributes of the Namespace.
        """
        self.data = OrderedDict()
        for k, v in kwargs:
            setattr(self, k, v)

    def __setitem__(self, key, value):
        """x.__setitem__(i, y) <==> x[i]=y"""
        value.name = Symbol(key)
        try:
            value.namespace
        except AttributeError:
            value.namespace = weakref.ref(self)
        else:
            if not(value.namespace):
                value.namespace = weakref.ref(self)
        super(Namespace, self).__setitem__(key, value)

    def __delitem__(self, key):
        """x.__delitem__(y) <==> del x[y]"""
        self[key].namespace = None
        super(Namespace, self).__delitem__(key)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return type(self).__name__ + repr(self.data)[11:]


class Enum(Namespace):
    """A Namespace which is being treated as an Enum.
    Enums can only contain Keywords or Symbols."""

    def __init__(self, *things):
        """Construct an Enum using a tuple of things."""
        self.data = OrderedDict()
        for thing in things:
            if type(thing) == str:
                thing = Symbol(thing)
            if not isinstance(thing, Symbol):
                raise TypeError(repr(thing) + " is not a Symbol")
            super(Enum, self).__setitem__(thing.name, thing)

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        v = [e for e in self.values()]
        return type(self).__name__ + "(" + repr(v) + ")"

    def __setitem__(self, key, value):
        """x.__setitem__(i, y) <==> x[i]=y"""
        if not isinstance(value, Keyword) and not isinstance(value, Symbol):
            raise TypeError("Enums can only contain Keywords or Symbols")
        raise ValueError("Enums cannot be modified after creation.")


class Symbol(str):
    """Use to scan Symbols.

    Class variables:
        regex               regular expression to scan, default r"\w+"
        check_keywords      flag if a Symbol is checked for not being a Keyword
                            default: False
    """

    regex = word
    check_keywords = False

    def __init__(self, name, namespace=None):
        """Construct a Symbol with that name in Namespace namespace.

        Raises:
            ValueError      if check_keywords is True and value is identical to
                            a Keyword
            TypeError       if namespace is given and not a Namespace
        """

        if Symbol.check_keywords and name in Keyword.table:
            raise ValueError(repr(name)
                    + " is a Keyword, but is used as a Symbol")
        if namespace:
            if isinstance(namespace, Namespace):
                namespace[name] = self
            else:
                raise TypeError(repr(namespace) + " is not a Namespace")
        else:
            self.name = name
            self.namespace = None

    def __repr__(self):
        """x.__repr__() <==> repr(x)"""
        return type(self).__name__ + "(" + str(self).__repr__() + ")"


class Keyword(Symbol):
    """Use to access the keyword table.

    Class variables:
        regex   regular expression to scan, default r"\w+"
        table   Namespace with keyword table
    """

    regex = word
    table = Namespace()

    def __init__(self, keyword):
        """Adds keyword to the keyword table."""
        Keyword.table[keyword] = self

K = Keyword
"""Shortcut for Keyword."""


class Concat(List):
    """Concatenation of things.

    This class exists as a mutable alternative to using a tuple.
    """


def name():
    """Generate a grammar for a symbol with name."""
    return attr("name", Symbol)


def ignore(grammar):
    """Ignore what matches to the grammar."""

    try:
        ignore.serial += 1
    except AttributeError:
        ignore.serial = 1
    return attr("_ignore" + str(ignore.serial), grammar)


def indent(*thing):
    """Indent thing by one level.
    Inserts -3 as cardinality before thing.
    """
    return _card(-3, thing)


endl = lambda thing, parser: "\n"
"""End of line marker for composing text."""


blank = lambda thing, parser: " "
"""Space marker for composing text."""


class GrammarError(Exception):
    """Base class for errors in grammars."""


class GrammarTypeError(TypeError, GrammarError):
    """Raised if grammar contains an object of unkown type."""


class GrammarValueError(ValueError, GrammarError):
    """Raised if grammar contains an illegal value."""


def how_many(grammar):
    """Determines the possibly parsed objects of grammar.

    Returns:
        0 if there will be no objects
        1 if there will be a maximum of one object
        2 if there can be more than one object
    
    Raises:
        GrammarTypeError
                    if grammar contains an object of unkown type
        GrammarValueError
                    if grammar contains an illegal cardinality value
    """

    if grammar is None:
        return 0

    elif type(grammar) == int:
        return grammar

    elif _issubclass(grammar, Symbol) or isinstance(grammar, (RegEx, _RegEx)):
        return 1

    elif isinstance(grammar, (str, Literal)):
        return 0

    elif isinstance(grammar, attr.Class):
        return 0

    elif type(grammar) == FunctionType:
        return 0

    elif isinstance(grammar, (tuple, Concat)):
        length, card = 0, 1
        for e in grammar:
            if type(e) == int:
                if e < -3:
                    raise GrammarValueError(
                        "illegal cardinality value in grammar: " + str(e))
                if e in (-1, -2):
                    card = 2
                elif e in (-3, 0):
                    card = 1
                else:
                    card = min(e, 2)
            else:
                length += card * how_many(e)
                if length >= 2:
                    return 2
        return length

    elif isinstance(grammar, list):
        return reduce(lambda a, b: max(how_many(a), how_many(b)), grammar)

    elif _issubclass(grammar, object):
        return 1

    else:
        raise GrammarTypeError("grammar contains an illegal type: "
                + type(grammar).__name__ + ": " + repr(grammar))


def parse(text, thing, filename=None, whitespace=whitespace, comment=None):
    """Parse text following thing as grammar and return the resulting things or
    raise an error.

    Arguments:
        text        text to parse
        thing       grammar for things to parse
        filename    filename where text is origin from
        whitespace  regular expression to _skip whitespace
                    default: regex "(?m)\s+"
        comment     grammar to parse comments
                    default: None

    Returns generated things.

    Raises:
        SyntaxError if text does not match the grammar in thing
        ValueError  if input does not match types
        TypeError   if output classes have wrong syntax for __init__()
        GrammarTypeError
                    if grammar contains an object of unkown type
        GrammarValueError
                    if grammar contains an illegal cardinality value
    """

    parser = Parser()
    parser.whitespace = whitespace
    parser.comment = comment
    parser.text = text
    parser.filename = filename

    t, r = parser.parse(text, thing)
    if t:
        raise parser.last_error
    return r


def compose(thing, grammar=None, indent="    "):
    """Compose text using thing with grammar.

    Arguments:
        thing           thing containing other things with grammar
        grammar         grammar to use to compose thing
                        default: thing.grammar
        indent          string to use to indent while composing
                        default: four spaces

    Returns text

    Raises:
        ValueError  if input does not match grammar
        GrammarTypeError
                    if grammar contains an object of unkown type
        GrammarValueError
                    if grammar contains an illegal cardinality value
    """

    parser = Parser()
    parser.indent = indent
    return parser.compose(thing, grammar)


def _issubclass(obj, cls):
    # If obj is not a class, just return False
    try:
        return issubclass(obj, cls)
    except TypeError:
        return False


class Parser(object):
    """Offers parsing and composing capabilities. Implements a Packrat parser.
    
    Instance variables:
        whitespace          regular expression to scan whitespace
                            default: "(?m)\s+"
        comment             grammar to parse comments
        last_error          syntax error which ended parsing
        indent              string to use to indent while composing
                            default: four spaces
        indention_level     level to indent to
                            default: 0
        text                original text to parse; set for decorated syntax
                            errors
        filename            filename where text is origin from
    """

    def __init__(self):
        """Initialize instance variables to their defaults."""
        self.whitespace = whitespace
        self.comment = None
        self.last_error = None
        self.indent = "    "
        self.indention_level = 0
        self.text = None
        self.filename = None
        self._memory = {}
        self._got_endl = True

    def parse(self, text, thing, filename=None):
        """(Partially) parse text following thing as grammar and return the
        resulting things.

        Arguments:
            text            text to parse
            thing           grammar for things to parse
            filename        filename where text is origin from

        Returns (text, result) with:
            text            unparsed text
            result          generated objects or SyntaxError object

        Raises:
            ValueError      if input does not match types
            TypeError       if output classes have wrong syntax for __init__()
            GrammarTypeError
                            if grammar contains an object of unkown type
            GrammarValueError
                            if grammar contains an illegal cardinality value
        """

        self.text = text
        if filename:
            self.filename = filename
        pos = [1, 0]
        t = self._skip(text, pos)
        t, r = self._parse(t, thing, pos)
        if type(r) == SyntaxError:
            raise r
        else:
            return t, r

    def _skip(self, text, pos=None):
        # Skip whitespace and comments from input text
        t2 = None
        t = text
        while t2 != t:
            if self.whitespace:
                t, r = self._parse(t, self.whitespace, pos)
            t2 = t
            if self.comment:
                t, r = self._parse(t, self.comment, pos)
        return t

    def _parse(self, text, thing, pos=[1, 0]):
        # Parser implementation

        def update_pos(text, t, pos):
            # Calculate where we are in the text
            if not pos:
                return
            if text == t:
                return
            d_text = text[:len(text) - len(t)]
            pos[0] += d_text.count("\n")
            pos[1] += len(d_text)

        try:
            return self._memory[(text, id(thing))]
        except KeyError:
            pass

        if pos: 
            current_pos = tuple(pos)
        else:
            current_pos = None

        def syntax_error(msg):
            # Create a syntax error construct with sensible attributes
            result = SyntaxError(msg)
            if pos:
                result.lineno = pos[0]
                start = max(pos[1] - 19, 0)
                end   = min(pos[1] + 20, len(self.text))
                result.text = self.text[start:end]
                result.offset = pos[1] - start + 1
                while "\n" in result.text:
                    lf = result.text.find("\n")
                    if lf >= result.offset:
                        result.text = result.text[:result.offset-1]
                        break;
                    else:
                        L = len(result.text)
                        result.text = result.text[lf+1:]
                        result.offset -= L - len(result.text)
                if self.filename:
                    result.filename = self.filename
            return result

        # terminal symbols

        if thing is None or type(thing) == FunctionType:
            result = text, None

        elif isinstance(thing, Symbol):
            m = type(thing).regex.match(text)
            if m and m.group(0) == str(thing):
                t, r = text[len(thing):], None
                t = self._skip(t)
                result = t, r
                update_pos(text, t, pos)
            else:
                result = text, syntax_error("expecting " + repr(thing))

        elif isinstance(thing, (RegEx, _RegEx)):
            m = thing.match(text)
            if m:
                t, r = text[len(m.group(0)):], m.group(0)
                t = self._skip(t)
                result = t, r
                update_pos(text, t, pos)
            else:
                result = text, syntax_error("expecting match on "
                        + thing.pattern)

        elif isinstance(thing, (str, Literal)):
            if text.startswith(thing):
                t, r = text[len(thing):], None
                t = self._skip(t)
                result = t, r
                update_pos(text, t, pos)
            else:
                result = text, syntax_error("expecting " + repr(thing))

        elif _issubclass(thing, Symbol):
            m = thing.regex.match(text)
            if m:
                result = None
                try:
                    thing.grammar
                except AttributeError:
                    pass
                else:
                    if thing.grammar is None:
                        pass
                    elif isinstance(thing.grammar, Enum):
                        if not m.group(0) in thing.grammar:
                            result = text, syntax_error(repr(m.group(0))
                                + " is not a member of " + repr(thing.grammar))
                    else:
                        raise GrammarValueError(
                                "Symbol " + type(thing).__name__
                                + " has a grammar which is not an Enum: "
                                + repr(thing.grammar))
                if not result:
                    t, r = text[len(m.group(0)):], thing(m.group(0))
                    t = self._skip(t)
                    result = t, r
                    update_pos(text, t, pos)
            else:
                result = text, syntax_error("expecting " + type(thing).__name__)

        # non-terminal constructs

        elif isinstance(thing, attr.Class):
            t, r = self._parse(text, thing.thing, pos)
            if type(r) == SyntaxError:
                if thing.subtype == "Flag":
                    result = t, attr(thing.name, False)
                else:
                    result = text, r
            else:
                if thing.subtype == "Flag":
                    result = t, attr(thing.name, True)
                else:
                    result = t, attr(thing.name, r)

        elif isinstance(thing, (tuple, Concat)):
            L = []
            t = text
            flag = True
            _min, _max = 1, 1
            for e in thing:
                if type(e) == int:
                    if e < -3:
                        raise GrammarValueError(
                            "illegal cardinality value in grammar: " + str(e))
                    if e == -3:
                        _min, _max = 1, 1
                    elif e == -2:
                        _min, _max = 1, sys.maxsize
                    elif e == -1:
                        _min, _max = 0, sys.maxsize
                    elif e ==  0:
                        _min, _max = 0, 1
                    else:
                        _min, _max = e, e
                    continue
                for i in range(_max):
                    t2, r = self._parse(t, e, pos)
                    if type(r) == SyntaxError:
                        i -= 1
                        break
                    else:
                        t = t2
                        if r != None:
                            if type(r) is list:
                                L.extend(r)
                            else:
                                L.append(r)
                if i+1 < _min:
                    if type(r) != SyntaxError:
                        r = syntax_error("expecting " + str(_min)
                                + " occurrence(s) of " + repr(e)
                                + " (" + str(i+1) + " found)")
                    flag = False
                    break
                _min, _max = 1, 1
            if flag:
                if len(L) > 1 or how_many(thing) > 1:
                    result = t, L
                elif not L:
                    return t, None
                else:
                    result = t, L[0]
            else:
                result = text, r

        elif isinstance(thing, list):
            found = False
            for e in thing:
                t, r = self._parse(text, e, pos)
                if type(r) != SyntaxError:
                    found = True
                    break
            if found:
                result = t, r
            else:
                result = text, syntax_error("expecting one of " + repr(thing))

        elif _issubclass(thing, Namespace):
            t, r = self._parse(text, thing.grammar, pos)
            if type(r) != SyntaxError:
                if isinstance(r, thing):
                    result = t, r
                else:
                    obj = thing()
                    for e in r:
                        if type(e) == attr.Class:
                            setattr(obj, e.name, e.thing)
                        else:
                            obj[e.name] = e
                    try:
                        obj.polish()
                    except AttributeError:
                        pass
                    result = t, obj
            else:
                result = text, r

        elif _issubclass(thing, list):
            try:
                g = thing.grammar
            except AttributeError:
                g = csl(Symbol)
            t, r = self._parse(text, g, pos)
            if type(r) != SyntaxError:
                if isinstance(r, thing):
                    result = t, r
                else:
                    obj = thing()
                    if type(r) == list:
                        for e in r:
                            if type(e) == attr.Class:
                                setattr(obj, e.name, e.thing)
                            else:
                                obj.append(e)
                    else:
                        if type(r) == attr.Class:
                            setattr(obj, r.name, r.thing)
                        else:
                            obj.append(r)
                    try:
                        obj.polish()
                    except AttributeError:
                        pass
                    result = t, obj
            else:
                result = text, r

        elif _issubclass(thing, object):
            try:
                g = thing.grammar
            except AttributeError:
                g = word
            t, r = self._parse(text, g, pos)
            if type(r) != SyntaxError:
                if isinstance(r, thing):
                    result = t, r
                else:
                    if type(r) == list:
                        L, a = [], []
                        for e in r:
                            if type(e) == attr.Class:
                                a.append(e)
                            else:
                                L.append(e)
                        if L:
                            lg = how_many(thing.grammar)
                            if lg == 0:
                                obj = None
                            elif lg == 1:
                                obj = thing(L[0])
                            else:
                                obj = thing(L)
                        else:
                            obj = thing()
                        for e in a:
                            setattr(obj, e.name, e.thing)
                    else:
                        if type(r) == attr.Class:
                            obj = thing()
                            setattr(obj, r.name, r.thing)
                        else:
                            if r is None:
                                obj = thing()
                            else:
                                obj = thing(r)
                    try:
                        obj.polish()
                    except AttributeError:
                        pass
                    result = t, obj
            else:
                result = text, r

        else:
            raise GrammarTypeError("in grammar: " + repr(thing))

        if pos:
            if type(result[1]) == SyntaxError:
                pos[0] = current_pos[0]
                pos[1] = current_pos[1]
                self.last_error = result[1]
            else:
                try:
                    result[1].position_in_text = current_pos
                except AttributeError:
                    pass

        self._memory[(text, id(thing))] = result
        return result

    def compose(self, thing, grammar=None):
        """Compose text using thing with grammar.

        Arguments:
            thing           thing containing other things with grammar
            grammar         grammar to use for composing thing
                            default: type(thing).grammar

        Returns text

        Raises:
            ValueError      if thing does not match grammar
            GrammarTypeError
                            if grammar contains an object of unkown type
            GrammarValueError
                            if grammar contains an illegal cardinality value
        """
        if __debug__:
            # make sure that we're not having this type error
            compose = None

        def terminal_indent():
            if self._got_endl:
                result = self.indent * self.indention_level
                self._got_endl = False
                return result
            else:
                return ""

        if not grammar:
            try:
                grammar = type(thing).grammar
            except AttributeError:
                if isinstance(thing, Symbol):
                    grammar = type(thing).regex
                elif isinstance(thing, list):
                    grammar = csl(Symbol)
                else:
                    grammar = word
            else:
                if isinstance(thing, Symbol):
                    grammar = type(thing).regex

        if grammar is None:
            result = ""

        elif type(grammar) == FunctionType:
            if grammar == endl:
                result = endl(thing, self)
                self._got_endl = True
            elif grammar == blank:
                result = terminal_indent() + blank(thing, self)
            else:
                result = self.compose(thing, grammar(thing, self))

        elif isinstance(grammar, (RegEx, _RegEx)):
            m = grammar.match(str(thing))
            if m:
                result = terminal_indent() + str(thing)
            else:
                raise ValueError(repr(thing) + " does not match "
                        + grammar.pattern)

        elif isinstance(grammar, (str, Literal)):
            result = terminal_indent() + str(grammar)

        elif isinstance(grammar, Enum):
            if thing in grammar:
                result = terminal_indent() + str(thing)
            else:
                raise ValueError(repr(thing) + " is not in " + repr(grammar))

        elif isinstance(grammar, attr.Class):
            if grammar.subtype == "Flag":
                if getattr(thing, grammar.name):
                    result = self.compose(grammar.thing)
                else:
                    result = terminal_indent()
            else:
                result = self.compose(getattr(thing, grammar.name),
                        grammar.thing)

        elif isinstance(grammar, (tuple, Concat)):
            def compose_tuple(thing, things, grammar):
                text = []
                multiple, card = 1, 1
                indenting = 0
                for g in grammar:
                    if g is None:
                        multiple = 1
                        if self.indenting:
                            self.indention_level -= indenting
                            self.indenting = 0
                    elif type(g) == int:
                        if g < -3:
                            raise GrammarValueError(
                                "illegal cardinality value in grammar: " +
                                str(g)
                            )
                        card = g
                        if g in (-2, -1):
                            multiple = sys.maxsize
                        elif g in (-3, 0):
                            multiple = 1
                            if g == -3:
                                self.indention_level += 1
                                indenting += 1
                        else:
                            multiple = g
                    else:
                        passes = 0
                        try:
                            for r in range(multiple):
                                if isinstance(g, (str, Symbol, Literal)):
                                    text.append(self.compose(thing, g))
                                    if card < 1:
                                        break
                                elif isinstance(g, FunctionType):
                                    text.append(self.compose(thing, g))
                                    if card < 1:
                                        break
                                elif isinstance(g, attr.Class):
                                    text.append(self.compose(thing, g))
                                    if card < 1:
                                        break
                                elif isinstance(g, (tuple, Concat)):
                                    text.append(compose_tuple(thing, things, g))
                                    if not things:
                                        break
                                else:
                                    text.append(self.compose(things.pop(), g))
                                passes += 1
                        except (IndexError, ValueError):
                            if card == -2:
                                if passes < 1:
                                    raise ValueError(repr(g)
                                            + " has to be there at least once")
                            elif card > 0:
                                if passes < multiple:
                                    raise ValueError(repr(g)
                                            + " has to be there exactly "
                                            + str(multiple) + " times")
                        multiple = 1
                        if indenting:
                            self.indention_level -= indenting
                            indenting = 0

                return ''.join(text)

            if isinstance(thing, Namespace):
                L = [e for e in thing.values()]
                L.reverse()
            elif isinstance(thing, list):
                L = thing[:]
                L.reverse()
            else:
                L = [thing]
            result = compose_tuple(thing, L, grammar)

        elif isinstance(grammar, list):
            found = False
            for g in grammar:
                try:
                    result = self.compose(thing, g)
                    found = True
                    break
                except GrammarTypeError:
                    raise
                except AttributeError:
                    pass
                except KeyError:
                    pass
                except TypeError:
                    pass
                except ValueError:
                    pass
            if not found:
                raise ValueError("none of the options in " + repr(grammar)
                        + " found")

        elif _issubclass(grammar, object):
            if isinstance(thing, grammar):
                try:
                    grammar.grammar
                except AttributeError:
                    if _issubclass(grammar, Symbol):
                        result = self.compose(thing, grammar.regex)
                    else:
                        result = self.compose(thing)
                else:
                    result = self.compose(thing, grammar.grammar)
            else:
                raise ValueError(repr(thing) + " is not a " + repr(grammar))

        else:
            raise GrammarTypeError("in grammar: " + repr(grammar))

        return result
