page "pyPEG – Features", "counter-reset: chapter 1;" {
    h1 id="features" > Features

    h2 id=basic > Basic Grammar Elements

    h3 id=literals > «str» instances

    h4 > Parsing

    p   >>
        A «str» instance is parsed in the source text as a
        `w "Terminal_and_nonterminal_symbols" > Terminal Symbol`.
        It is removed and no result is put into the ∫Abstract syntax tree∫.
        If it does not exist at the correct position in the source text,
        a «SyntaxError» ist generated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), ◊"="◊, restline, endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        'something'
        ||

    h4 > Composing

    p > «str» instances are being output literally.

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), ◊"="◊, restline, endl
        ... 
        >>> k = Key("a value")
        >>> k.name = Symbol("give me")
        >>> compose(k)
        'give me◊=◊a value\\n'
        ||

    h3 id=regex > Regular Expressions

    h4 > Parsing

    p   >>
        ƒpyPEG uses Python's «re» module. «pypeg2.RegEx» is an alias for
        πre.html#re-objects Python Regular Expression Objectsπ.
        Regular Expressions are parsed as
        `w "Terminal_and_nonterminal_symbols" > Terminal Symbols`. The matching 
        result is put into the ¬#ast AST¬. If no match can be achieved, a 
        «SyntaxError» is generated.
        >>

    p   >>
        ƒpyPEG predefines different RegEx objects:
        >>

    table border=1 {
        tr {
            td Code > word = re.compile(r"\w+")
            td p > Regular expression for scanning a word.
        }

        tr {
            td Code > restline = re.compile(r".*")
            td p > Regular expression for rest of line.
        }

        tr {
            td Code > whitespace = re.compile("(?m)\s+")
            td p > Regular expression for scanning whitespace.
        }
    }

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), "=", ◊restline◊, endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        ◊'something'◊
        ||

    h4 > Composing

    p   >>
        For «RegEx» objects their corresponding value in the ¬#ast AST¬ will be
        output. If this value does not match the «RegEx» a «ValueError» is raised.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), "=", ◊restline◊, endl
        ... 
        >>> k = Key(◊"a value"◊)
        >>> k.name = Symbol("give me")
        >>> compose(k)
        'give me=◊a value\\n◊'
        ||

    h3 id=tuple > «tuple» instances

    h4 > Parsing

    p   >>
        A «tuple» specifies, that different things have to be parsed one after
        another. If not all of them parse in their sequence, a «SyntaxError» is
        generated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name()◊, ◊"="◊, ◊restline◊, ◊endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        'something'
        ||

    p   >>
        In a «tuple» there may be integers preceding another thing in the
        «tuple». These integers represent a cardinality. For example, to parse
        three times a «word», you can have as a «grammar»:
        >>

    Code | grammar = word, word, word

    p > or:

    Code | grammar = 3, word

    p > which is equivalent. There are special cardinality values:

    table border=1 {
        tr {
            td Code > -2, thing
            td p > «some(thing)»; this represents the plus cardinality, +
        }
        tr {
            td Code > -1, thing
            td p > «maybe_some(thing)»; this represents the asterisk cardinality, *
        }
        tr {
            td Code > 0, thing
            td p > «optional(thing)»; this represents the question mark cardinality, ?
        }
    }

    p   >>
        The special cardinality values can be generated with the
        ¬#cardfuncs Cardinality Functions¬.  The value «-3» is reserved for the
        indention system. Other negative values are reserved and may not be
        used.
        >>

    h4 > Composing

    p   >>
        For «tuple» objects all attributes of the corresponding thing (and
        elements of the corresponding collection if that applies) in the
        ¬#ast AST¬ will be composed and the result is concatenated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name()◊, ◊"="◊, ◊restline◊, ◊endl
        ... 
        >>> k = Key("a value")
        >>> k.name = Symbol("give me")
        >>> compose(k)
        ◊'give me=a value\\n'◊
        ||

    h3 id=lists > «list» instances

    h4 > Parsing

    p   >>
        A «list» instance represents different options. They're tested in their
        sequence. The first option which parses is chosen, the others are not
        tested any more. If none matches, a «SyntaxError» is generated.
        >>

    p > Example:

    Code 
        ||
        >>> number = re.compile(r"\d+")
        >>> parse("hello", ◊[number, word]◊)
        'hello'
        ||

    h4 > Composing

    p   >>
        The elements of the «list» are tried out in their sequence, if one of
        them can be composed. If none can a «ValueError» is raised.
        >>

    p > Example:

    Code
        ||
        >>> letters = re.compile(r"[a-zA-Z]")
        >>> number = re.compile(r"\d+")
        >>> compose(23, ◊[letters, number]◊)
        '23'
        ||

    h2 id=goclasses > Grammar Element Classes

    h3 id=symbol > Class «Symbol(str)»

    p > Used to scan a «Symbol».

    p   >>
        If you're putting a «Symbol» somewhere in your «grammar», then
        «Symbol.regex» is used to scan while parsing. The result will be a
        «Symbol» instance. Optionally it is possible to check that a «Symbol»
        instance will not be identical to any «Keyword» instance.  This can be
        helpful if the source language forbids that.
        >>

    h4 > Class variables

    table border=1 {
        tr {
            td p code > regex
            td p > regular expression to scan, default «r"\w+"»
        }
        tr {
            td p code > check_keywords
            td p > flag if a «Symbol» has to be checked for not being a «Keyword»; default: «False»
        }
    }

    h4 > Method «__init__(self, name, namespace=None)»

    p > Construct a «Symbol» with that «name» in «namespace».

    h5 > Raises:

    table border=1 {
        tr {
            td p code > ValueError
            td p > if «check_keywords» is «True» and value is identical to a «Keyword»
        }

        tr {
            td p code > TypeError
            td p > if «namespace» is given and not an instance of «Namespace»
        }
    }
}
