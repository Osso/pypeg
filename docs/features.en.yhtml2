page "pyPEG – Features", "counter-reset: chapter 1;" {
    h1 id="features" > Features

    h2 id=basic > Basic Grammar Elements

    h3 id=literals > «str» instances

    h4 > Parsing

    p   >>
        A «str» instance is parsed in the source text as a
        `w "Terminal_and_nonterminal_symbols" > Terminal Symbol`.
        It is removed and no result is put into the ∫Abstract syntax tree∫.
        If it does not exist at the correct position in the source text,
        a «SyntaxError» ist generated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), ◊"="◊, restline, endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        'something'
        ||

    h4 > Composing

    p > «str» instances are being output literally.

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), ◊"="◊, restline, endl
        ... 
        >>> k = Key("a value")
        >>> k.name = Symbol("give me")
        >>> compose(k)
        'give me◊=◊a value\\n'
        ||

    h3 id=regex > Regular Expressions

    h4 > Parsing

    p   >>
        ƒpyPEG uses Python's «re» module. «pypeg2.RegEx» is an alias for
        πre.html#re-objects Python Regular Expression Objectsπ.
        Regular Expressions are parsed as
        `w "Terminal_and_nonterminal_symbols" > Terminal Symbols`. The matching 
        result is put into the ¬#ast AST¬. If no match can be achieved, a 
        «SyntaxError» is generated.
        >>

    p   >>
        ƒpyPEG predefines different RegEx objects:
        >>

    table border=1 {
        tr {
            td p code > word = re.compile(r"\w+")
            td p > Regular expression for scanning a word.
        }

        tr {
            td p code > restline = re.compile(r".*")
            td p > Regular expression for rest of line.
        }

        tr {
            td p code > whitespace = re.compile("(?m)\s+")
            td p > Regular expression for scanning whitespace.
        }
    }

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), "=", ◊restline◊, endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        ◊'something'◊
        ||

    h4 > Composing

    p   >>
        For «RegEx» objects their corresponding value in the ¬#ast AST¬ will be
        output. If this value does not match the «RegEx» a «ValueError» is raised.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), "=", ◊restline◊, endl
        ... 
        >>> k = Key(◊"a value"◊)
        >>> k.name = Symbol("give me")
        >>> compose(k)
        'give me=◊a value\\n◊'
        ||

    h3 id=tuple > «tuple» instances

    h4 > Parsing

    p   >>
        A «tuple» specifies, that different things have to be parsed one after
        another. If not all of them parse in their sequence, a «SyntaxError» is
        generated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name()◊, ◊"="◊, ◊restline◊, ◊endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        'something'
        ||

    p   >>
        In a «tuple» there may be integers preceding another thing in the
        «tuple». These integers represent a cardinality. For example, to parse
        three times a «word», you can have as a «grammar»:
        >>

    Code | grammar = word, word, word

    p > or:

    Code | grammar = 3, word

    p > which is equivalent. There are special cardinality values:

    table border=1 {
        tr {
            td p code > -2, thing
            td p > «some(thing)»; this represents the plus cardinality, +
        }
        tr {
            td p code > -1, thing
            td p > «maybe_some(thing)»; this represents the asterisk cardinality, *
        }
        tr {
            td p code > 0, thing
            td p > «optional(thing)»; this represents the question mark cardinality, ?
        }
    }

    p   >>
        The special cardinality values can be generated with the
        ¬#cardfuncs Cardinality Functions¬.  The value «-3» is reserved for the
        indention system. Other negative values are reserved and may not be
        used.
        >>

    h4 > Composing

    p   >>
        For «tuple» objects all attributes of the corresponding thing (and
        elements of the corresponding collection if that applies) in the
        ¬#ast AST¬ will be composed and the result is concatenated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name()◊, ◊"="◊, ◊restline◊, ◊endl
        ... 
        >>> k = Key("a value")
        >>> k.name = Symbol("give me")
        >>> compose(k)
        ◊'give me=a value\\n'◊
        ||

    h3 id=lists > «list» instances

    h4 > Parsing

    p   >>
        A «list» instance represents different options. They're tested in their
        sequence. The first option which parses is chosen, the others are not
        tested any more. If none matches, a «SyntaxError» is generated.
        >>

    p > Example:

    Code 
        ||
        >>> number = re.compile(r"\d+")
        >>> parse("hello", ◊[number, word]◊)
        'hello'
        ||

    h4 > Composing

    p   >>
        The elements of the «list» are tried out in their sequence, if one of
        them can be composed. If none can a «ValueError» is raised.
        >>

    p > Example:

    Code
        ||
        >>> letters = re.compile(r"[a-zA-Z]")
        >>> number = re.compile(r"\d+")
        >>> compose(23, ◊[letters, number]◊)
        '23'
        ||

    h2 id=goclasses > Grammar Element Classes

    h3 id=symbol > Class «Symbol(str)»

    p > Used to scan a «Symbol».

    p   >>
        If you're putting a «Symbol» somewhere in your «grammar», then
        «Symbol.regex» is used to scan while parsing. The result will be a
        «Symbol» instance. Optionally it is possible to check that a «Symbol»
        instance will not be identical to any «Keyword» instance.  This can be
        helpful if the source language forbids that.
        >>

    p   >>
        A class which is derived from «Symbol» can have an «Enum» as its
        «grammar» only. Other values for its «grammar» are forbidden and will
        generate a «TypeError». If such an «Enum» is specified, each parsed
        value will be checked if being a member of this «Enum» additionally to
        the «RegEx» matching.
        >>

    h4 > Class variables

    table border=1 {
        tr {
            td p code > regex
            td p > regular expression to scan, default «r"\w+"»
        }
        tr {
            td p code > check_keywords
            td p > flag if a «Symbol» has to be checked for not being a «Keyword»; default: «False»
        }
    }

    h4 > Instance variables

    table border=1 {
        tr {
            td p code > name
            td p > name of the «Keyword» as «str» instance
        }
    }

    h4 > Method «__init__(self, name, namespace=None)»

    p > Construct a «Symbol» with that «name» in «namespace».

    h5 > Raises:

    table border=1 {
        tr {
            td p code > ValueError
            td p > if «check_keywords» is «True» and value is identical to a «Keyword»
        }

        tr {
            td p code > TypeError
            td p > if «namespace» is given and not an instance of «Namespace»
        }
    }

    h4 > Parsing

    p   >>
        Parsing a «Symbol» is done by scanning with «Symbol.regex». In our
        example we're using the «name()» function, which is often used to parse
        a «Symbol». «name()» equals to «attr("name", Symbol)».
        >>

    p > Example:

    Code
        ||
        >>> ◊Symbol.regex = re.compile(r"[\w\s]+")◊
        >>> class Key(str):
        ...     grammar = ◊name()◊, "=", restline, endl
        ...
        >>> k = parse("this one=foo bar", Key)
        >>> k.name
        ◊Symbol('this one')◊
        >>> k
        'foo bar'
        ||

    h4 > Composing

    p > Composing a «Symbol» is done by converting it to text.

    p > Example:

    Code
        ||
        >>> k.name = ◊Symbol("that one")◊
        >>> print(compose(k))
        ◊that one◊=foo bar
        ||

    h3 id=keyword > Class «Keyword(Symbol)»

    p > Used to access the keyword table.

    p   >>
        The «Keyword» class is meant to be instanciated for each «Keyword» of
        the source language. The class holds the keyword table as a «Namespace»
        instance. There is the abbreviation «K» for «Keyword». The latter is
        useful for instancing keywords.
        >>

    h4 > Class variables

    table border=1 {
        tr {
            td p code > regex
            td p > regular expression to scan; default «r"\w+"»
        }
        tr {
            td p code > table
            td p > «Namespace» with keyword table
        }
    }

    h4 > Instance variables

    table border=1 {
        tr {
            td p code > name
            td p > name of the «Keyword» as «str» instance
        }
    }

    h4 > Method «__init__(self, keyword)»

    p > Adds «keyword» to the keyword table.

    h4 > Parsing

    p   >>
        When a «Keyword» instance is parsed, it is removed and nothing is put
        into the resulting ¬#ast AST¬. When a «Keyword» class is parsed, an
        instance is created and put into the ¬#ast AST¬.
        >>

    p > Example:

    Code
        ||
        >>> class ◊Type(Keyword)◊:
        ...     grammar = ◊Enum( K("int"), K("long") )◊
        ... 
        >>> k = parse("long", ◊Type◊)
        >>> k.name
        'long'
        ||

    h4 > Composing

    p   >>
        When a «Keyword» instance is in a «grammar», it is converted into a
        «str» instance, and the resulting text is added to the result. When a
        «Keyword» class is in the «grammar», the correspoding instance in the
        ¬#ast AST¬ is converted into a «str» instance and added to the result.
        >>

    p > Example:

    Code
        ||
        >>> k = ◊K("do")◊
        >>> print(compose(k))
        do
        ||

    div id="bottom" {
        "Want to download? Go to the "
        a "#top", "^Top^"; " and look to the right ;-)"
    }
}
