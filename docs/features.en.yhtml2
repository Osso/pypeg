page "pyPEG – Features" {
    h1 id=overview "Overview";

    p > ƒpyPEG provides the following things:

    h1 id=basic > Basic Grammar Elements

    h2 id=literals > String objects

    h3 > Parsing

    p   >>
        String objects are parsed as
        `w "Terminal_and_nonterminal_symbols" > Terminal Symbols`.
        They're removed and no result is put into the ∫Abstract syntax tree∫.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), ◊"="◊, restline, endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        'something'
        ||

    h3 > Composing

    p > String objects are being output literally.

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), ◊"="◊, restline, endl
        ... 
        >>> k = Key("a value")
        >>> k.name = Symbol("give me")
        >>> compose(k)
        'give me◊=◊a value\\n'
        ||

    h2 id=regex > Regular Expressions

    h3 > Parsing

    p   >>
        ƒpyPEG uses Python's «re» module. «pypeg2.RegEx» is an alias for
        πre.html#re-objects Python Regular Expression Objectsπ.
        Regular Expressions are parsed as
        `w "Terminal_and_nonterminal_symbols" > Terminal Symbols`. The matching 
        result is put into the ¬#ast AST¬.
        >>

    p   >>
        ƒpyPEG predefines different RegEx objects:
        >>

    table border=1 {
        tr {
            td Code > word = re.compile(r"\w+")
            td p > Regular expression for scanning a word.
        }

        tr {
            td Code > restline = re.compile(r".*")
            td p > Regular expression for rest of line.
        }

        tr {
            td Code > whitespace = re.compile("(?m)\s+")
            td p > Regular expression for scanning whitespace.
        }
    }

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), "=", ◊restline◊, endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        ◊'something'◊
        ||

    h3 > Composing

    p   >>
        For «RegEx» objects their corresponding value in the ¬#ast AST¬ will be
        output.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name(), "=", ◊restline◊, endl
        ... 
        >>> k = Key(◊"a value"◊)
        >>> k.name = Symbol("give me")
        >>> compose(k)
        'give me=◊a value\\n◊'
        ||

    h2 id=tuple > Tuples

    h3 > Parsing

    p   >>
        A «tuple» specifies, that different things have to be parsed one after
        another. Example:
        >>

    Code
        ||
        >>> class Key(str):
        ...     grammar = name()◊, ◊"="◊, ◊restline◊, ◊endl
        ... 
        >>> k = parse("this=something", Key)
        >>> k.name
        Symbol('this')
        >>> k
        'something'
        ||

    p   >>
        In a «tuple» there may be integers preceding another thing in the
        «tuple». These integers represent a cardinality. For example, to parse
        three times a «word», you can have as a «grammar»:
        >>

    Code | grammar = word, word, word

    p > or:

    Code | grammar = 3, word

    p > which is equivalent. There are special cardinality values:

    table border=1 {
        tr {
            td Code > -2, thing
            td p > «some(thing)»; this represents the plus cardinality, +
        }
        tr {
            td Code > -1, thing
            td p > «maybe_some(thing)»; this represents the asterisk cardinality, *
        }
        tr {
            td Code > 0, thing
            td p > «optional(thing)»; this represents the question mark cardinality, ?
        }
    }

    p   >>
        The special cardinality values can be generated with the
        ¬#cardfuncs Cardinality Functions¬.  The value «-3» is reserved for the
        indention system. Other negative values are reserved and may not be
        used.
        >>

    h3 > Composing

    p   >>
        For «tuple» objects all attributes of the corresponding thing (and
        elements of the corresponding collection if that applies) in the
        ¬#ast AST¬ will be composed and the result is concatenated.
        >>

    p > Example:

    Code
        ||
        >>> class Key(str):
        ...     grammar = name()◊, ◊"="◊, ◊restline◊, ◊endl
        ... 
        >>> k = Key("a value")
        >>> k.name = Symbol("give me")
        >>> compose(k)
        ◊'give me=a value\\n'◊
        ||

    h2 id=lists > Lists

}
